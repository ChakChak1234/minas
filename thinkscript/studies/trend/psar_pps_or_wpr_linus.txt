$linus: Scalping study 

## START STUDY 

## PSAR_PPS_WR 

## linus, 2014-01-27, v0.1 

 

#hint: Parabolic SAR adjusted by ATR with signals generated by PPS and/or WilliamsPercentR. 

 

#hint paintBars: Yes to color price bars. 

input paintBars = No; 

 

#hint signals: Type of signal arrows: Both uses WilliamsPercentR (WR) and PPS, otherwise set to PPS or WR to generate signals. 

input signals = {default Both, PPS, WR}; 

 

#hint altSignals: No to show all the signals, otherwise alternate signals. 

input altSignals = Yes;  

 

#hint signalLength: Period length to offset signals. 

input signalLength = 20; 

 

#hint signalOffset: Additional signal offset in ticks. 

input signalOffset = 2.0;  

 

plot Up; 

plot Dn; 

 

rec ppsDir = CompoundValue(1, if !IsNaN(PPS().BuySignal) then 1 else if !IsNaN(PPS().SellSignal) then -1 else ppsDir[1], 0); 

 

################################################################ 

# WilliamsPercentR 

 

#hint wrLength: Period length for WilliamsPercentR. 

input wrLength = 10; 

 

#hint wrMidLine: Yes to signal on midline, otherwise use overbought/oversold lines, for WilliamsPercentR signal. 

input wrMidLine = Yes;   

 

def hh = Highest(high, wrLength); 

def ll = Lowest(low, wrLength); 

def result = if hh == ll then -100 else (hh - close) / (hh - ll) * (-100); 

def WR = if result > 0 then 0 else result; 

 

rec wrDir = CompoundValue(1,  

if wrMidLine then 

    if WR > -50 then 1 else if WR < -50 then -1 else wrDir[1] 

else  

    if WR > -20 then 1 else if WR < -80 then -1 else wrDir[1] 

, 0); 

 

################################################################ 

# Parabolic SAR modified with ATR (PSAR) 

# Borrowed from Mobius' V01.01.2010 version. 

 

#hint atrLength: Period length for average true range. 

input atrLength = 5; 

 

#hint accFactor: Acceleration factor for PSAR. 

input accFactor = 0.001; 

 

#hint accLimit: Acceleration limit for PSAR. 

input accLimit = 0.002; 

 

def ATR = Average(TrueRange(high, close, low), atrLength); 

def factor = ATR * accFactor; 

def limit = ATR; 

 

# PSAR States: (I)nit, (L)ong, (S)hort. 

def st = {default I, L, S}; 

def xt; 

def SAR; 

def acc; 

 

switch (st[1]) { 

case I: 

    st = st.L; 

    acc = factor; 

    xt = high; 

    SAR = low; 

case S: 

    if (SAR[1] < high) 

    then { 

        st = st.L; 

        acc = factor; 

        xt = high; 

        SAR = xt[1]; 

    } else { 

        st = st.S; 

        if (low < xt[1]) 

        then { 

            acc = Min(acc[1] + factor, limit); 

            xt = low; 

        } else { 

            acc = acc[1]; 

            xt = xt[1]; 

        } 

        SAR = Max(Max(high, high[1]), SAR[1] + acc * (xt - SAR[1])); 

    } 

case L: 

    if (SAR[1] > low) 

    then { 

        st = st.S; 

        acc = factor; 

        xt = low; 

        SAR = xt[1]; 

    } else { 

        st = st.L; 

        if (high > xt[1]) 

        then { 

            acc = Min(acc[1] + factor, limit); 

            xt = high; 

        } else { 

            acc = acc[1]; 

            xt = xt[1]; 

        } 

        SAR = Min(Min(low, low[1]), SAR[1] + acc * (xt - SAR[1])); 

    } 

} 

 

plot PSAR = SAR; 

PSAR.DefineColor("Up", Color.WHITE); 

PSAR.DefineColor("Dn", Color.ORANGE); 

PSAR.SetPaintingStrategy(PaintingStrategy.POINTS); 

PSAR.AssignValueColor(if st == st.L then PSAR.Color("Up") else PSAR.Color("Dn")); 

 

rec dir; 

if signals == signals.PPS { 

    dir = ppsDir; 

} else if signals == signals.WR {  

    dir = wrDir; 

} else { 

    dir = if ppsDir > 0 and wrDir > 0 then 1 

          else if ppsDir < 0 and wrDir < 0 then -1 

    else dir[1]; 

} 

 

rec sig = CompoundValue(1,  

    if st == st.L and dir > 0 then 1  

    else if st == st.S and dir < 0 then -1  

    else if !altSignals and dir crosses 0 then 0  

    else sig[1] 

, 0); 

 

Up = if sig crosses above 0 then Lowest(low, signalLength) - ticksize() * signalOffset else Double.NaN; 

Up.SetPaintingStrategy(PaintingStrategy.ARROW_UP); 

Up.SetDefaultColor(Color.CYAN); 

Up.SetLineWeight(2); 

 

Dn = if sig crosses below 0 then Highest(high, signalLength) + ticksize() * signalOffset else Double.NaN; 

Dn.SetPaintingStrategy(PaintingStrategy.ARROW_DOWN); 

Dn.SetDefaultColor(Color.MAGENTA); 

Dn.SetLineWeight(2); 

 

AssignPriceColor(if !paintBars then Color.CURRENT 

else if dir > 0 then  

    if close > open then Color.GREEN  

    else Color.DARK_GREEN  

else if close < open then Color.RED  

else Color.PINK); 

 

## END STUDY 